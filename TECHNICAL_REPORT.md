# 技术实现报告：C++ 命令行参数解析器

## 1. 项目背景 (Background)
作为一个 Linux C++ 初学者，我通过构建这个工具深入理解了操作系统如何传递参数给程序，以及如何使用 C++ 面向对象编程来封装复杂的逻辑。

## 2. 核心技术点 (Key Technologies)

### 2.1 命令行参数的本质 (`argc` & `argv`)
- **原理解析**：`main` 函数的 `int argc` 代表参数个数，`char* argv[]` 代表参数数组。
- **遇到的挑战**：`argv[0]` 永远是程序名，真正的用户参数从索引 1 开始。在遍历时需要小心数组越界（Segment Fault），特别是在读取 `-o filename` 这种带值的参数时，必须检查 `i + 1 < argc`。

### 2.2 数据结构的选择 (Data Structures)
我在项目中使用了两种 STL 容器，它们解决了不同的问题：

1.  **`std::vector<Option>`**
    - **用途**：用于存储所有“注册”过的合法选项（如 `-n`, `--name`）。
    - **为什么用它**：因为我们需要按顺序遍历所有规则来匹配用户的输入，Vector 提供了高效的线性存储。
    - **用法**：通过push_back()把规则存进列表

2.  **`std::map<std::string, std::string>`**
    - **用途**：用于存储解析后的结果。
    - **为什么用它**：Map 提供了 `Key-Value`（键值对）的映射能力。
    - **技巧**：我实现了“归一化”存储。无论用户输入 `-n` 还是 `--name`，我都统一以长选项 `--name` 作为 Key 存入 Map。这样在查询时，只需要查 `--name` 即可，大大简化了逻辑。

### 2.3 模块化编程 (Modularization)
我将代码拆分为三个部分：
- **`ArgParser.h` (头文件)**：作为“说明书”，声明了类和接口，使用了 `#ifndef` 防止重复引用。
- **`ArgParser.cpp` (源文件)**：作为“实现者”，包含了具体的函数逻辑。
- **`main.cpp` (主程序)**：只负责调用接口，保持了业务逻辑的清晰。

## 3. 项目心得 (Conclusion)
通过这个项目，我从最基本的 `cout` 打印，进阶到了使用 STL 容器、类封装、多文件编译以及 Git 版本控制。这为我后续进行更复杂的 Linux 开发打下了基础。